<!doctype html>
<html lang="en">
<!--
{% comment %}
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to you under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
{% endcomment %}
-->
<meta charset="utf-8">
<title>Calcite Rule Match Visualization</title>

<script src="https://d3js.org/d3.v7.min.js" charset="utf-8"></script>
<script src="https://dagrejs.github.io/project/dagre-d3/latest/dagre-d3.min.js"></script>
<script src="https://unpkg.com/tippy.js@3/dist/tippy.all.min.js"></script>
<script src="volcano-viz-data.js"></script>

<style id="css">
    body {
        height: 100vh;
        width: 100vw;
        margin: 0 0;
        color: #333;
        font-weight: 300;
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
    }

    li a {
        display: block;
        /* and you can use padding for additional space if needs, as a clickable area / or other styling */
        padding: 5px 20px;
    }

    section {
        margin-bottom: 3em;
    }

    section p {
        text-align: justify;
    }

    svg {
        overflow: hidden;
        margin: 0 auto;
    }

    pre {
        border: 1px solid #ccc;
    }

    #rule-list-column {
        border-left: 1px solid #ccc;
    }

    .clusters rect {
        fill: #FFFFE0;
        stroke: #999;
        stroke-width: 1.5px;
    }

    text {
        font-weight: 300;
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
        font-size: 2em;
    }

    .node rect {
        stroke: #999;
        fill: #fff;
        stroke-width: 1.5px;
    }

    .edgePath path {
        stroke: #333;
        stroke-width: 2px;
    }

    .container {
        overflow: hidden;
        width: 100%;
        height: 100%;
        display: flex;
        flex-flow: row nowrap;
    }

    .column1 {
        display: flex;
        flex-flow: column nowrap;
    }

    .column2 {
        flex: 0 1 100%;
    }

    .tippy-content {
        word-break: break-all;
        word-wrap: break-word;
    }

    button {
        padding: 0.1em;
        display: inline-block;
        font-size: 2em;
        min-width: 1.5em;
    }
</style>

<div class="container">
    <div class="column2">
        <div id="toolbar">
            <button id="left-button" style="display:inline-block">⤿</button>
            <button id="right-button" style="display:inline-block">⤾</button>
            <button id="fit-content-button" style="display:inline-block">⇿</button>
            <span>&nbsp;</span>
            <button id="toggle-list-button">≡</button>
            <button id="prev-button" disabled>◀</button>
            <button id="next-button" disabled>▶</button>
            <div id="current-rule" style="display: inline-block"></div>
        </div>
        <svg id="svg-canvas" width="100%" height="100%" ></svg>
    </div>
    <div id="rule-list-column" class="column1">
        <div style="width: 100%; text-align: center">
        </div>
        <ol id="rule-match-list" style="overflow: auto" start="0">
        </ul>
    </div>
</div>

<script id="js">

    var allNodes = data.allNodes;
    var nodeAddedInRule = data.nodeAddedInRule;
    var rankDirs = ["BT", "RL", "TB", "LR"];

    /*
     * Graph data and D3 JS render related variables
     */

    // Create the input graph
    var g = new dagreD3.graphlib.Graph({
            compound: true
        })
        .setGraph({
            rankdir: 'LR',
        })
        .setDefaultEdgeLabel(function () {
            return {};
        });

    // Create the renderer
    var render = new dagreD3.render();

    // Set up an SVG group so that we can translate the final graph.
    var svg = d3.select("svg");
    var svgGroup = svg.append("g");

    // Set up zoom support
    const zoom = d3.zoom().on('zoom', (e) => svgGroup.attr('transform', e.transform));
    var svg = d3.select('svg')
        .call(zoom);

    var fitContent = () => {
        const { x, y, width, height } = svgGroup.node().getBBox();
        const { clientWidth, clientHeight } = svg.node();
        if (width && height) {
            const scale = Math.min(clientWidth / width, clientHeight / height) * 0.98
            zoom.scaleTo(svg, scale)
            zoom.translateTo(svg, width/2+x , height/2+y )
        }
    };

    /*
     * Global State
     */

    var currentRuleIndex = 0;
    var currentRankDirIdx = 0;

    /*
     * Event Handler functions
     */

    var updateLocation = () => {
        var urlParams = new URLSearchParams(location.search); 
        urlParams.set("rule", currentRuleIndex);
        urlParams.set("dir", currentRankDirIdx);
        window.history.pushState({}, "", "?" + urlParams.toString());
    };

    var parseLocation = () => {
        var urlParams = new URLSearchParams(location.search); 
        if (urlParams.has("rule")) {
            var ruleIdx = Number(urlParams.get("rule"))
            if (Number.isInteger(ruleIdx))
                currentRuleIndex = ruleIdx;
        }
        if (urlParams.has("dir")) {
            var dirIdx = Number(urlParams.get("dir"))
            if (Number.isInteger(ruleIdx) && ruleIdx >= 0 && ruleIdx < rankDirs.length)
                currentRankDirIdx = dirIdx;
        }
    };

    var setCurrentRule = (ruleMatchIndex) => {
        // un-highlight previous entry
        var prevRuleIndex = currentRuleIndex;
        if (prevRuleIndex !== undefined) {
            var prevRuleElement = document.getElementById(data.ruleMatchSequence[prevRuleIndex]);
            prevRuleElement.style.backgroundColor = "#FFFFFF";
        }

        currentRuleIndex = ruleMatchIndex;
        var currentRuleID = data.ruleMatchSequence[ruleMatchIndex];
        document.getElementById('current-rule').innerText = currentRuleIndex + ": " + currentRuleID;

        var currentRuleElement = document.getElementById(currentRuleID);
        currentRuleElement.style.backgroundColor = "#D3D3D3";

        document.getElementById("prev-button").disabled = false;
        document.getElementById("next-button").disabled = false;

        if (currentRuleIndex === 0) {
            document.getElementById("prev-button").disabled = true;
        }
        if (currentRuleIndex === data.ruleMatchSequence.length - 1) {
            document.getElementById("next-button").disabled = true;
        }

        updateGraph();
    }

    var updateGraph = () => {
        updateLocation();
        var ruleMatchID = data.ruleMatchSequence[currentRuleIndex];
        var ruleMatchInfo = data.ruleMatchInfoMap[ruleMatchID]

        // remove previous rendered view and clear graph model
        d3.select("svg g").selectAll("*").remove();
        g.nodes().slice().forEach(nodeID => g.removeNode(nodeID));

        // create nodes and sets
        for (var setID in ruleMatchInfo.nodesInSet) {
            // add set
            var setLabel = ruleMatchInfo.setLabels[setID];
            if (setLabel === null || setLabel === undefined) {
                setLabel = setID;
            }
            g.setNode(setID, {
                label: setLabel,
                clusterLabelPos: 'top'
            });
            // add nodes and node-set parent relationship
            var nodes = ruleMatchInfo.nodesInSet[setID];

            nodes.forEach(nodeID => {
                nodeInfo = allNodes[nodeID];
                var nodeLabel;
                if (ruleMatchID === "FINAL") {
                    nodeLabel = nodeInfo.label + "--" + nodeInfo.finalCost;
                } else {
                    nodeLabel = nodeInfo.label;
                }
                var nodeStyle;
               if (ruleMatchInfo.importanceZeroNodes
                    && ruleMatchInfo.importanceZeroNodes.includes(nodeID)) {
                    nodeStyle = "fill: #D3D3D3"
                } else if (ruleMatchID !== "INITIAL" && ruleMatchInfo.newNodes.includes(nodeID)) {
                    nodeStyle = "fill: #E0FFFF";
                } else if (ruleMatchInfo.matchedNodes.includes(nodeID)) {
                    nodeStyle = "fill: #C8C8F3";
                } else {
                    nodeStyle = "fill: #FFFFFF";
                }
                g.setNode(nodeID, {
                    label: nodeLabel,
                    style: nodeStyle
                });
                g.setParent(nodeID, setID);
            });
        }

        // create links
        for (var nodeID in ruleMatchInfo.nodeInputs) {
            var nodeInfo = allNodes[nodeID];
            ruleMatchInfo.nodeInputs[nodeID].forEach(inputID => {
                var inputNodeInfo = allNodes[inputID];
                var edgeOptions = { arrowheadStyle: "normal" };
                if (nodeInfo.subset && inputNodeInfo.subset) {
                    edgeOptions = { style: "stroke-dasharray: 5, 5; fill: none;" };
                }
                g.setEdge(inputID, nodeID, edgeOptions);
            });
        }

        g.setGraph({
            rankdir: rankDirs[currentRankDirIdx]
        })

        // re-render
        render(d3.select("svg g"), g);

        // register tooltip popup
        const allD3Nodes = d3.select('svg').selectAll('.node');
        const allD3NodeElements = allD3Nodes.nodes();

        tippy.setDefaults({
            trigger: "click",
            interactive: true,
        });

        var i = 0;
        allD3Nodes.each(nodeID => {
            var nodeElement = allD3NodeElements[i];
            var popupContent = allNodes[nodeID].explanation;
            popupContent += "<br>Added in Rule - "  + nodeAddedInRule[nodeID];

            tippy(nodeElement, { content: popupContent })
            i++;
        });
    }

    /*
     * render HTML Element and add event hanlders
     */

    // populate UI list
    var ruleListElement = document.getElementById("rule-match-list");
    data.ruleMatchSequence.forEach((ruleMatchID, index) => {
        var listItem = document.createElement("li");
        var textItem = document.createElement("a");
        textItem.innerText = ruleMatchID;
        textItem.id = ruleMatchID;
        textItem.setAttribute("href", "#");

        listItem.appendChild(textItem);
        ruleListElement.appendChild(listItem);
        listItem.addEventListener("click", event => {
            setCurrentRule(index);
        })
    })

    document.getElementById("prev-button").addEventListener("click", event => {
        if (currentRuleIndex !== 0) {
            setCurrentRule(currentRuleIndex - 1);
        }
    });

    document.getElementById("next-button").addEventListener("click", event => {
        if (currentRuleIndex !== data.ruleMatchSequence.length - 1) {
            setCurrentRule(currentRuleIndex + 1);
        }
    });

    document.getElementById("left-button").addEventListener("click", event => {
        currentRankDirIdx += 1;
        if (currentRankDirIdx >= rankDirs.length)
            currentRankDirIdx = 0;
        updateGraph();
    });

    document.getElementById("right-button").addEventListener("click", event => {
        currentRankDirIdx -= 1;
        if (currentRankDirIdx < 0)
            currentRankDirIdx = 3;
        updateGraph();
    });

    document.getElementById("fit-content-button").addEventListener("click", fitContent);

    document.getElementById("toggle-list-button").addEventListener("click", () => {
        var col1 = document.getElementById("rule-list-column");
        if (col1.style.display === "none") 
            col1.style.display = "";
        else 
            col1.style.display = "none";
    });

    // render initial state
    
    parseLocation();
    setCurrentRule(currentRuleIndex);
    fitContent();
</script>

</html>
